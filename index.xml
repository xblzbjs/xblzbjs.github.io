<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>行百里者半九十</title>
    <link>https://xblzbjs.cn/</link>
    <description>Recent content on 行百里者半九十</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xblzbjs&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 24 May 2021 09:17:09 +0800</lastBuildDate><atom:link href="https://xblzbjs.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>启示录-打造用户喜爱的产品(人员篇)</title>
      <link>https://xblzbjs.cn/article/2021/05/%E5%90%AF%E7%A4%BA%E5%BD%95-%E6%89%93%E9%80%A0%E7%94%A8%E6%88%B7%E5%96%9C%E7%88%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BA%BA%E5%91%98%E7%AF%87/</link>
      <pubDate>Mon, 24 May 2021 09:17:09 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/05/%E5%90%AF%E7%A4%BA%E5%BD%95-%E6%89%93%E9%80%A0%E7%94%A8%E6%88%B7%E5%96%9C%E7%88%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BA%BA%E5%91%98%E7%AF%87/</guid>
      <description>关键角色及其职责 1. 产品经理 主要职责
 评估产品机会（product opportunity）  产品需求文档(market requirements document, MRD)结合产品原型 机会评估(opportunity assessment)   定义要开发的产品  基本的产品特征和功能 产品的用户的体验 产品的发布标准    2. 用户体验设计师 主要职责
 与产品经理密切合作，将功能与设计相结合，满足用户需求，确保产品同时具有可用性和价值  注：产品的用户体验是公司的核心竞争力；交互设计不能外包，质量检验更适合外包
3. 项目管理人员 主要职责
 制定计划 跟踪进度  4. 开发团队 注：IT团队通常指的是为内部员工提供技术支持的团队，而开发团队指的是为外部客户开发和维护产品的团队。
5. 运维团队 6. 产品营销人员 主要职责
 对外发布信息、宣传产品 组织重点营销活动 促进产品销售提供支持  注：不推荐让一个人同时负责产品管理和产品营销
团队成员的构成比例  通常，每五到十位开发人员配备一位产品经理 一位交互设计师支持两位产品经理的工作 一位视觉设计师支持四位交互设计师的工作 凡是超过十名开发人员参与的项目，就应该配备专职的项目经理  产品管理与软件开发 开发人员帮助产品经理完善产品定义的方式  邀请一名开发人员参加产品原型测试 产品经理可以向开发人员了解最新的技术发展动向，讨论哪些新技术可以用到产品里。 让开发人员在探索产品的初期阶段参与评估产品设计，协助策划方案。  注：产品经理常犯一类错误，即完成产品定义后，便扔给开发团队，置之不理。这样做只会贻误协调需求与可行性的最佳时机，等到发现问题时，为时已晚。
产品经理页配合开发人员工作的方式  产品经理应该意识到，自己要定义的不是最终产品，而是满足基本要求的产品 一旦产品进入开发阶段，要尽可能避免修改产品的需求和设计 产品经理应该迅速采取行动，在维持产品基本功能、尽量避免修改的原则上，拿出解决方案  关于业务外包  外包不是为了节约成本，而是为了实现合理的人员配置 外包的关键是要挑选有能力的员工。聘用五位精英组成的团队比雇佣十五个平庸的人要更好  如何避免崩溃的软件架构  未雨绸缪，预留一定的技术能力，eBay称为余量（headroom） 为用户数量的增长预留空间，为事务增长预留空间，为新增功能预留空间 在产品管理上为开发团队预留**20%**的自主时间，让他们自由支配 把重写目标分成几大块，实现递增修改，让用户感受到产品的改进  招聘产品经理 技术可以学习，素质却难以培养。</description>
    </item>
    
    <item>
      <title>启示录-打造用户喜爱的产品(流程篇)</title>
      <link>https://xblzbjs.cn/article/2021/05/%E5%90%AF%E7%A4%BA%E5%BD%95-%E6%89%93%E9%80%A0%E7%94%A8%E6%88%B7%E5%96%9C%E7%88%B1%E7%9A%84%E4%BA%A7%E5%93%81%E6%B5%81%E7%A8%8B%E7%AF%87/</link>
      <pubDate>Mon, 24 May 2021 09:17:09 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/05/%E5%90%AF%E7%A4%BA%E5%BD%95-%E6%89%93%E9%80%A0%E7%94%A8%E6%88%B7%E5%96%9C%E7%88%B1%E7%9A%84%E4%BA%A7%E5%93%81%E6%B5%81%E7%A8%8B%E7%AF%87/</guid>
      <description>开发富有创意的产品时反复应用的流程和成功的实践经验
评估产品机会 确定待解决的问题 产品经理应该能回答如下十个问题
 产品要解决什么问题？（产品价值※） 为谁解决这个问题？（目标市场） 成功的机会有多大？（市场规模） 怎样判断产品成功与否？（度量指标或收益指标） 有哪些同类产品？（竞争格局） 为什么我们最适合做这个产品？（竞争优势） 时机合适码？（市场时机） 如何把产品推向市场？（营销组合策略） 成功的必要条件是什么？（解决方案要满足的条件） 根据以上问题，给出评估结论（继续或放弃）  产品探索 定义正确的产品   在探索产品的阶段，产品经理负责分析各种创意，广泛搜集用户需求，了解如何运用新技术，拿出产品原型并加以测试，从全局视角思考产品方向，兼顾短期需求和长期规划。
  产品经理必须在执行阶段转换工作中心；否则，产品经理自己很可能成为产品上市的最大障碍。
  采用流水线方式并行开发产品。也就是说，一旦1.0版本的产品进入项目执行阶段，就开始定义2.0的产品。
  产品原则 产品原则是对团队信仰和价值观的总结，用来指导产品团队作出正确的决策和取舍。
确定什么最重要  罗列出产品原则，并按原则的重要性排序 切记原则过于空泛 切记将设计原则当成产品原则  解决意见冲突 在做产品决策之前，应该先确定决策要解决什么问题，让大家在以下几个要点上达成共识。
 究竟要解决什么问题？ 要为哪类人物角色解决这个问题？ 产品要达到什么目标 每项目标的优先级是什么？  产品评审团 制定决策通常是既耗时又费力的。产品公司需要一套机制让决策者和相关人员及时作出明智的产品决策，成立产品评审团是最好的解决途径之一。
工作目标  决定产品战略方向，从宏观上监督公司产品的研发流程，合理地配置资源。 不制定公司的商业战略，而是在给定商业战略的条件下，提出与之相匹配的产品战略。  成员组成  首席执行官/首席运营官/部门总经理 产品管理总监/副总监 用户体验设计总监/副总监 市场总监/副总监 技术总监/副总监 网站运营总监/副总监 客户服务总监/副总监  主要职责 根据研发产品的四个里程碑来评审产品，制定决策
 评审产品战略和产品路线图，选择值得投入经理的产品，请产品经理开始评估产品机会 根据评估产品机会的结果，决定是否开始定义产品的解决方案 评审产品原型、用户测试结果、成本估算明细，决定是否开始开发产品。 评审最终产品、产品品质、发布计划、社会效应，决定是否发布产品  特约用户（不是特别重要） 市场调研 常用的市场调研工具和方法  用户调查 产品使用分析 数据挖掘 拜访用户 人物角色 可用性测试 同类产品分析  利用市场调研工具和方法时需要时刻思考以下几个关键问题</description>
    </item>
    
    <item>
      <title>常见的HTTP返回状态码</title>
      <link>https://xblzbjs.cn/article/2021/05/%E5%B8%B8%E8%A7%81%E7%9A%84http%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81/</link>
      <pubDate>Sun, 23 May 2021 09:17:09 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/05/%E5%B8%B8%E8%A7%81%E7%9A%84http%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81/</guid>
      <description>状态码的类别 实际上经常使用的大概只有十几种
    类别 原因     1XX Informational（信息性状态码） 接收的请求正在处理   2XX Success（成功状态码） 请求正常处理完毕   3XX Redirection（重定向状态码） 需要进行附加操作以完成请求   4XX Client Error（客户端错误状态码） 服务器无法处理请求   5XX Server Error（服务器错误状态码） 服务器处理请求出错    常用2XX状态码（表明请求被正常处理）     说明     200 OK 正常处理   204 No Content 请求处理成功！但没有资源可返回   206 Partial Content 成功执行范围请求，响应报文中包含由 Content-Range 指定范围的实体内容。    常用3XX状态码（表明浏览器需要执行某些特殊的处理以正确处理）     说明     301 Moved Permanently 永久性重定向。当指定资源路径（例如http://example.</description>
    </item>
    
    <item>
      <title>Vim｜补全</title>
      <link>https://xblzbjs.cn/article/2021/03/vim%E8%A1%A5%E5%85%A8/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/vim%E8%A1%A5%E5%85%A8/</guid>
      <description>常用 补全单词  control + n control + p  补全文件名  control + x control + f  补全代码(需要开启文件类型检查，安装插件)  control + x control + o  </description>
    </item>
    
    <item>
      <title>Vim｜搜索替换</title>
      <link>https://xblzbjs.cn/article/2021/03/vim%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/vim%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2/</guid>
      <description>单个文件搜索替换操作 :[range]s[ubsitute]/{pattern}/{string}/[flags]
参数  range: 表示范围。比如:10,20代表10-20行， %代表全部。 pattern: 替换的模式. string: 替换后的文本。 flags: 替换的标志。g表示全局范围内执行；c表示确认，可以确认或者拒绝修改；n报告匹配到的次数而不替换，可以用来查询匹配次数  举个🌰 # 把文件中world全部替换成WORLD:% s/world/WORLD/g# 统计1-20行 world单词出现的个数:1,5 s/world//n# 正则表达式精确匹配:% s/\&amp;lt;world\&amp;gt;/WORLD/</description>
    </item>
    
    <item>
      <title>高效程序员的45个习惯:敏捷开发修炼之道</title>
      <link>https://xblzbjs.cn/article/2021/03/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</link>
      <pubDate>Thu, 25 Mar 2021 09:17:09 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</guid>
      <description>有关敏捷    &amp;ldquo;敏捷&amp;quot;是一种把以人为本、团队合作、快速响应变化和可工作的软件作为宗旨的开发方法
    反馈是敏捷的基础。一旦你意识到走错了方向，就要立即做出决策，改变方向。
    过程符合标准并不意味结果是正确的。敏捷团队重结果胜于重过程。
   自我提升    你要不断从自己写的代码中得到反馈，并且使用自动化工具不断地构建（持续集成）和测试系统。在前进过程中，你都会有意识地修改一些代码：在功能不变的情况下，重新设计部分代码，改善代码的质量。这就是所谓的重构，它是软件开发中不可或缺的一部分——编码永远没有真正意义上的“结束”。
    先难后易。我们首先要解决困难的问题，把简单的问题留到最后.
    不要孤立地编码(Don’t code in isolation)
    要专业而不是自我
    迭代和增量式的学习。每天计划用一段时间来学习新技术，它不需要很长时间，但需要经常进行。记下那些你想学习的东西——当你听到一些不熟悉的术语或者短语时，简要地把它记录下来。然后在计划的时间中深入研究它。
    跟踪技术变化。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯。
    你不可能精通每一项技术，没有必要去做这样的尝试。只要你在某些方面成为专家，就能使用同样的方法，很容易地成为新领域的专家。
    你要明白为什么需要这项新技术——它试图解决什么样的问题？它可以被用在什么地方？
    不停地问为什么。不能只满足于别人告诉你的表面现象。要不停地提问直到你明白问题的根源。
    解决任务，在事情变得一团糟之前。保持事件之间稳定重复的间隔，更容易解决常见的重复任务。</description>
    </item>
    
    <item>
      <title>Go｜testing.M</title>
      <link>https://xblzbjs.cn/article/2021/03/gotesting.m/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/gotesting.m/</guid>
      <description>因何而生❓ 有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, testing 包提供了 TestMain 函数 :
func TestMain(m *testing.M) 有什么作用🤔 如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。m. Run将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己
调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析
因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便
举个🌰 简单 // file name: demo_test.go package tests import ( &amp;#34;testing&amp;#34; &amp;#34;os&amp;#34; ) func TestMain(m *testing.M) { log.Println(&amp;#34;Do stuff BEFORE the tests!&amp;#34;) exitVal := m.Run() log.Println(&amp;#34;Do stuff AFTER the tests!&amp;#34;) os.Exit(exitVal) } func TestA(t *testing.T) { log.Println(&amp;#34;TestA running&amp;#34;) } func TestB(t *testing.T) { log.Println(&amp;#34;TestB running&amp;#34;) } 输出 $ go test -v demo_test.</description>
    </item>
    
    <item>
      <title>Go｜testing.T</title>
      <link>https://xblzbjs.cn/article/2021/03/gotesting.t/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/gotesting.t/</guid>
      <description>因何而生❓ 有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, testing 包提供了 TestMain 函数 :
func TestMain(m *testing.M) 有什么作用🤔 如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。m. Run将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己
调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析
因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便
举个🌰 简单 // file name: demo_test.go package tests import ( &amp;#34;testing&amp;#34; &amp;#34;os&amp;#34; ) func TestMain(m *testing.M) { log.Println(&amp;#34;Do stuff BEFORE the tests!&amp;#34;) exitVal := m.Run() log.Println(&amp;#34;Do stuff AFTER the tests!&amp;#34;) os.Exit(exitVal) } func TestA(t *testing.T) { log.Println(&amp;#34;TestA running&amp;#34;) } func TestB(t *testing.T) { log.Println(&amp;#34;TestB running&amp;#34;) } 输出 $ go test -v demo_test.</description>
    </item>
    
    <item>
      <title>Python｜结构型设计模式</title>
      <link>https://xblzbjs.cn/article/2021/03/python%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 13:45:56 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/python%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>结构型模式 常见的结构型设计模式：
 工厂模式（Factory）：解决对象创建问题 构造模式（Builder）：控制复杂对象的创建 原型模式（Prototype）：通过原型的克隆创建新的实例 单例（Borg/Singleton）：一个类只能创建同一个对象 对象池模式（Pool）：预先分配同一类型的一组实例 惰性计算模式（Lazy Evaluation）：延迟计算（python的property）  装饰器模式 什么是装饰器（Decorator）
 Python中一切皆对象，函数也可以当作参数传递 装饰器是接受函数作为参数，添加功能后返回一个新函数的函数（类） 通过@使用装饰器  import time def log_time(func): # 接受一个函数作为参数 def _log(*args, **kwargs): beg = time.time() res = func(*args, **kwargs) print(&amp;#39;use time:{}&amp;#39;.format(time.time()-beg)) return res return _log @log_time # @:装饰器语法糖 def mysleep(): time.sleep(1) newsleep = log_time(mysleep) # 等价于mysleep() newsleep() mysleep() import time # 装饰器类实现 class LogTime: def __init__(self, use_int=False): self.use_int = use_int # 增加参数 def __call__(self,func): def _log(*args, **kwargs): beg = time.</description>
    </item>
    
    <item>
      <title>Python｜行为型设计模式</title>
      <link>https://xblzbjs.cn/article/2021/03/python%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 13:45:56 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/python%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>常见学习行为型设计模式  迭代器模式（Iterator）：通过统一的接口迭代对象 观察者模式（Observer）：对象发生改变的时候，观察者执行相应动作 策略模式（Strategy）：针对不同规模输入使用不同的策略  迭代器模式  Python内置对迭代器模式的支持 可用for遍历各种Iterable的数据类型 可以实现__next__和__iter__实现迭代器  class Stack(object): # 使用组合的例子 def __init__(self): self._deque = deque() def push(self, value): return self._deque.append(value) def pop(self): return self._deque.pop() def empty(self): return len(self._deque) == 0 def __iter__(self): res = [] for i in self._deque: res.append(i) for i in reversed(res): yield i s = Stack() s.push(1) s.push(2) for i in s: print(i) 观察者模式  发布订阅是一种最常用的实现方式 发布订阅用于解耦逻辑 可以通过回调等方式实现，当发生事件，执行回调函数  ==TODO：代码实现==
策略模式  根据不同的输入采用不同的策略 对外暴露统一的接口，内部采用不同的策略计算  ==TODO：代码实现==</description>
    </item>
    
  </channel>
</rss>
