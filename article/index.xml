<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>行百里者半九十</title>
    <link>https://xblzbjs.cn/article/</link>
    <description>Recent content on 行百里者半九十</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xblzbjs&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 24 May 2021 09:17:09 +0800</lastBuildDate><atom:link href="https://xblzbjs.cn/article/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>启示录-打造用户喜爱的产品(人员篇)</title>
      <link>https://xblzbjs.cn/article/2021/05/%E5%90%AF%E7%A4%BA%E5%BD%95-%E6%89%93%E9%80%A0%E7%94%A8%E6%88%B7%E5%96%9C%E7%88%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BA%BA%E5%91%98%E7%AF%87/</link>
      <pubDate>Mon, 24 May 2021 09:17:09 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/05/%E5%90%AF%E7%A4%BA%E5%BD%95-%E6%89%93%E9%80%A0%E7%94%A8%E6%88%B7%E5%96%9C%E7%88%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BA%BA%E5%91%98%E7%AF%87/</guid>
      <description>关键角色及其职责 1. 产品经理 主要职责
 评估产品机会（product opportunity）  产品需求文档(market requirements document, MRD)结合产品原型 机会评估(opportunity assessment)   定义要开发的产品  基本的产品特征和功能 产品的用户的体验 产品的发布标准    2. 用户体验设计师 主要职责
 与产品经理密切合作，将功能与设计相结合，满足用户需求，确保产品同时具有可用性和价值  注：产品的用户体验是公司的核心竞争力；交互设计不能外包，质量检验更适合外包
3. 项目管理人员 主要职责
 制定计划 跟踪进度  4. 开发团队 注：IT团队通常指的是为内部员工提供技术支持的团队，而开发团队指的是为外部客户开发和维护产品的团队。
5. 运维团队 6. 产品营销人员 主要职责
 对外发布信息、宣传产品 组织重点营销活动 促进产品销售提供支持  注：不推荐让一个人同时负责产品管理和产品营销
团队成员的构成比例  通常，每五到十位开发人员配备一位产品经理 一位交互设计师支持两位产品经理的工作 一位视觉设计师支持四位交互设计师的工作 凡是超过十名开发人员参与的项目，就应该配备专职的项目经理  产品管理与软件开发 开发人员帮助产品经理完善产品定义的方式  邀请一名开发人员参加产品原型测试 产品经理可以向开发人员了解最新的技术发展动向，讨论哪些新技术可以用到产品里。 让开发人员在探索产品的初期阶段参与评估产品设计，协助策划方案。  注：产品经理常犯一类错误，即完成产品定义后，便扔给开发团队，置之不理。这样做只会贻误协调需求与可行性的最佳时机，等到发现问题时，为时已晚。
产品经理页配合开发人员工作的方式  产品经理应该意识到，自己要定义的不是最终产品，而是满足基本要求的产品 一旦产品进入开发阶段，要尽可能避免修改产品的需求和设计 产品经理应该迅速采取行动，在维持产品基本功能、尽量避免修改的原则上，拿出解决方案  关于业务外包  外包不是为了节约成本，而是为了实现合理的人员配置 外包的关键是要挑选有能力的员工。聘用五位精英组成的团队比雇佣十五个平庸的人要更好  如何避免崩溃的软件架构  未雨绸缪，预留一定的技术能力，eBay称为余量（headroom） 为用户数量的增长预留空间，为事务增长预留空间，为新增功能预留空间 在产品管理上为开发团队预留**20%**的自主时间，让他们自由支配 把重写目标分成几大块，实现递增修改，让用户感受到产品的改进  招聘产品经理 技术可以学习，素质却难以培养。</description>
    </item>
    
    <item>
      <title>Vim｜补全</title>
      <link>https://xblzbjs.cn/article/2021/03/vim%E8%A1%A5%E5%85%A8/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/vim%E8%A1%A5%E5%85%A8/</guid>
      <description>常用 补全单词  control + n control + p  补全文件名  control + x control + f  补全代码(需要开启文件类型检查，安装插件)  control + x control + o  </description>
    </item>
    
    <item>
      <title>Vim｜搜索替换</title>
      <link>https://xblzbjs.cn/article/2021/03/vim%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/vim%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2/</guid>
      <description>单个文件搜索替换操作 :[range]s[ubsitute]/{pattern}/{string}/[flags]
参数  range: 表示范围。比如:10,20代表10-20行， %代表全部。 pattern: 替换的模式. string: 替换后的文本。 flags: 替换的标志。g表示全局范围内执行；c表示确认，可以确认或者拒绝修改；n报告匹配到的次数而不替换，可以用来查询匹配次数  举个🌰 # 把文件中world全部替换成WORLD:% s/world/WORLD/g# 统计1-20行 world单词出现的个数:1,5 s/world//n# 正则表达式精确匹配:% s/\&amp;lt;world\&amp;gt;/WORLD/</description>
    </item>
    
    <item>
      <title>高效程序员的45个习惯:敏捷开发修炼之道</title>
      <link>https://xblzbjs.cn/article/2021/03/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</link>
      <pubDate>Thu, 25 Mar 2021 09:17:09 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</guid>
      <description>有关敏捷    &amp;ldquo;敏捷&amp;quot;是一种把以人为本、团队合作、快速响应变化和可工作的软件作为宗旨的开发方法
    反馈是敏捷的基础。一旦你意识到走错了方向，就要立即做出决策，改变方向。
    过程符合标准并不意味结果是正确的。敏捷团队重结果胜于重过程。
   自我提升    你要不断从自己写的代码中得到反馈，并且使用自动化工具不断地构建（持续集成）和测试系统。在前进过程中，你都会有意识地修改一些代码：在功能不变的情况下，重新设计部分代码，改善代码的质量。这就是所谓的重构，它是软件开发中不可或缺的一部分——编码永远没有真正意义上的“结束”。
    先难后易。我们首先要解决困难的问题，把简单的问题留到最后.
    不要孤立地编码(Don’t code in isolation)
    要专业而不是自我
    迭代和增量式的学习。每天计划用一段时间来学习新技术，它不需要很长时间，但需要经常进行。记下那些你想学习的东西——当你听到一些不熟悉的术语或者短语时，简要地把它记录下来。然后在计划的时间中深入研究它。
    跟踪技术变化。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯。
    你不可能精通每一项技术，没有必要去做这样的尝试。只要你在某些方面成为专家，就能使用同样的方法，很容易地成为新领域的专家。
    你要明白为什么需要这项新技术——它试图解决什么样的问题？它可以被用在什么地方？
    不停地问为什么。不能只满足于别人告诉你的表面现象。要不停地提问直到你明白问题的根源。
    解决任务，在事情变得一团糟之前。保持事件之间稳定重复的间隔，更容易解决常见的重复任务。</description>
    </item>
    
    <item>
      <title>Go｜testing.M</title>
      <link>https://xblzbjs.cn/article/2021/03/gotesting.m/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/gotesting.m/</guid>
      <description>因何而生❓ 有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, testing 包提供了 TestMain 函数 :
func TestMain(m *testing.M) 有什么作用🤔 如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。m. Run将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己
调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析
因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便
举个🌰 简单 // file name: demo_test.go package tests import ( &amp;#34;testing&amp;#34; &amp;#34;os&amp;#34; ) func TestMain(m *testing.M) { log.Println(&amp;#34;Do stuff BEFORE the tests!&amp;#34;) exitVal := m.Run() log.Println(&amp;#34;Do stuff AFTER the tests!&amp;#34;) os.Exit(exitVal) } func TestA(t *testing.T) { log.Println(&amp;#34;TestA running&amp;#34;) } func TestB(t *testing.T) { log.Println(&amp;#34;TestB running&amp;#34;) } 输出 $ go test -v demo_test.</description>
    </item>
    
    <item>
      <title>Go｜testing.T</title>
      <link>https://xblzbjs.cn/article/2021/03/gotesting.t/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/gotesting.t/</guid>
      <description>因何而生❓ 有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, testing 包提供了 TestMain 函数 :
func TestMain(m *testing.M) 有什么作用🤔 如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。m. Run将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己
调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析
因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便
举个🌰 简单 // file name: demo_test.go package tests import ( &amp;#34;testing&amp;#34; &amp;#34;os&amp;#34; ) func TestMain(m *testing.M) { log.Println(&amp;#34;Do stuff BEFORE the tests!&amp;#34;) exitVal := m.Run() log.Println(&amp;#34;Do stuff AFTER the tests!&amp;#34;) os.Exit(exitVal) } func TestA(t *testing.T) { log.Println(&amp;#34;TestA running&amp;#34;) } func TestB(t *testing.T) { log.Println(&amp;#34;TestB running&amp;#34;) } 输出 $ go test -v demo_test.</description>
    </item>
    
    <item>
      <title>Python｜结构型设计模式</title>
      <link>https://xblzbjs.cn/article/2021/03/python%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 13:45:56 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/python%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>结构型模式 常见的结构型设计模式：
 工厂模式（Factory）：解决对象创建问题 构造模式（Builder）：控制复杂对象的创建 原型模式（Prototype）：通过原型的克隆创建新的实例 单例（Borg/Singleton）：一个类只能创建同一个对象 对象池模式（Pool）：预先分配同一类型的一组实例 惰性计算模式（Lazy Evaluation）：延迟计算（python的property）  装饰器模式 什么是装饰器（Decorator）
 Python中一切皆对象，函数也可以当作参数传递 装饰器是接受函数作为参数，添加功能后返回一个新函数的函数（类） 通过@使用装饰器  import time def log_time(func): # 接受一个函数作为参数 def _log(*args, **kwargs): beg = time.time() res = func(*args, **kwargs) print(&amp;#39;use time:{}&amp;#39;.format(time.time()-beg)) return res return _log @log_time # @:装饰器语法糖 def mysleep(): time.sleep(1) newsleep = log_time(mysleep) # 等价于mysleep() newsleep() mysleep() import time # 装饰器类实现 class LogTime: def __init__(self, use_int=False): self.use_int = use_int # 增加参数 def __call__(self,func): def _log(*args, **kwargs): beg = time.</description>
    </item>
    
    <item>
      <title>Python｜行为型设计模式</title>
      <link>https://xblzbjs.cn/article/2021/03/python%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 13:45:56 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/python%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>常见学习行为型设计模式  迭代器模式（Iterator）：通过统一的接口迭代对象 观察者模式（Observer）：对象发生改变的时候，观察者执行相应动作 策略模式（Strategy）：针对不同规模输入使用不同的策略  迭代器模式  Python内置对迭代器模式的支持 可用for遍历各种Iterable的数据类型 可以实现__next__和__iter__实现迭代器  class Stack(object): # 使用组合的例子 def __init__(self): self._deque = deque() def push(self, value): return self._deque.append(value) def pop(self): return self._deque.pop() def empty(self): return len(self._deque) == 0 def __iter__(self): res = [] for i in self._deque: res.append(i) for i in reversed(res): yield i s = Stack() s.push(1) s.push(2) for i in s: print(i) 观察者模式  发布订阅是一种最常用的实现方式 发布订阅用于解耦逻辑 可以通过回调等方式实现，当发生事件，执行回调函数  ==TODO：代码实现==
策略模式  根据不同的输入采用不同的策略 对外暴露统一的接口，内部采用不同的策略计算  ==TODO：代码实现==</description>
    </item>
    
    <item>
      <title>创建型设计模式</title>
      <link>https://xblzbjs.cn/article/2021/03/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 13:45:56 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>常见创建型设计模式  工厂模式（Factory）：解决对象创建问题 构造模式（Builder）：控制复杂对象的创建 原型模式（Prototype）：通过原型的克隆创建新的实例 单例（Borg/Singleton）：一个类只能创建同一个对象 对象池模式（Pool）：预先分配同一类型的一组实例 惰性计算模式（Lazy Evaluation）：延迟计算（python的property）  1.工厂模式 解决了什么问题：
 解决对象创建问题 解耦对象的创建和使用 包括工厂方法和抽象工厂  # 工厂方法 class DogToy: def speak(self): print(&amp;#34;wang wang&amp;#34;) class CatToy: def speak(self): print(&amp;#34;miao miao&amp;#34;) def toy_factory(toy_type): if toy_type == &amp;#39;dog&amp;#39;: return DogToy() elif toy_type == &amp;#39;cat&amp;#39;: return CatToy() 2.构造模式 什么是构造模式：
 用来控制复杂对象的构造 创建和表示分离。比如你要买电脑，工厂模式直接给你需要的电脑 但是构造模式允许你自己定义电脑的配置，组装完成后给你  3.原型模式 什么是原型模式：
 通过克隆原型来创建新的实例 可以通过相同的原型，通过修改部分属性来创建新的实例 用途：对于一些创建实例开销比较高的地方可以用原型模式  4.单例模式（重点） 单例模式的实现由多种方式
 单例模式：一个类创建出来的对象都是同一个 Python的模块其实就是单例的，只会导入一次（import） 使用共享同一个实例的方式来创建单例模式  # 单例模式 class Singleton: def __new__(cls, *args, **kwargs): if not hasattr(cls, &amp;#39;_instance&amp;#39;): _instance = super().</description>
    </item>
    
    <item>
      <title>zsh｜主题</title>
      <link>https://xblzbjs.cn/article/2021/03/zsh%E4%B8%BB%E9%A2%98/</link>
      <pubDate>Fri, 19 Mar 2021 13:24:17 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/article/2021/03/zsh%E4%B8%BB%E9%A2%98/</guid>
      <description>所有主题 我喜欢的自带主题 agnoster amuse awesomepanda clean crcandy frisk jonathan linuxonly（只能运行在linux） nanotech philips pmcgee xiong-chiamiov 额外的主题 powerlevel10k spaceship-prompt </description>
    </item>
    
  </channel>
</rss>
